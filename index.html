from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import StreamingResponse, JSONResponse
from fastapi.middleware.cors import CORSMiddleware
import fitz  # PyMuPDF
import io
import re
import urllib.parse
import unicodedata
from typing import Optional


import firebase_admin
from firebase_admin import credentials, auth

cred = credentials.Certificate("utmatic-firebase.json")
firebase_admin.initialize_app(cred)


from google.cloud import firestore
db = firestore.Client()

def save_submission(user_id, filename, url):
    doc = {
        "user_id": user_id,
        "filename": filename,
        "url": url,
        "timestamp": firestore.SERVER_TIMESTAMP
    }
    db.collection("submissions").add(doc)



app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "https://frontend-ten-alpha-65.vercel.app",
        "https://frontend-baipfc7fn-john-snivelys-projects.vercel.app"
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
    expose_headers=["X-Link-Count"]
)

def format_to_regex_list(fmt_string):
    formats = [f.strip() for f in fmt_string.split(",")]
    regexes = []
    for fmt in formats:
        escaped = re.escape(fmt)
        regex = escaped.replace("N", r"\d").replace("L", r"[A-Za-z]")
        regexes.append(re.compile(rf"\b{regex}\b"))
    return regexes

def extract_last_path_segment(url: str) -> str:
    parsed = urllib.parse.urlparse(url)
    path = parsed.path.strip("/")
    return path.split("/")[-1] if path else "link"

def int_to_rgb(color_int):
    r = ((color_int >> 16) & 255) / 255
    g = ((color_int >> 8) & 255) / 255
    b = (color_int & 255) / 255
    return (r, g, b)

def process_pdf_logic(contents, source, medium, campaign, job_type, target_format=None, base_url=None):
    final_pdf = fitz.open(stream=contents, filetype="pdf")
    preview_pdf = fitz.open(stream=contents, filetype="pdf")
    red_rects = []
    link_count = 0

    utm_base = f"?utm_source={urllib.parse.quote(source)}&utm_medium={urllib.parse.quote(medium)}&utm_campaign={urllib.parse.quote(campaign)}"

    for page_num in range(len(final_pdf)):
        final_page = final_pdf[page_num]
        preview_page = preview_pdf[page_num]

        if job_type == "utm_only":
            links = final_page.get_links()
            for link in links:
                if "uri" in link:
                    original = link["uri"]
                    rect = fitz.Rect(link["from"])
                    original = link["uri"]
                    rect = fitz.Rect(link["from"])
                    visible_text = final_page.get_textbox(rect).strip()
                    if " " in visible_text:
                        utm_val = extract_last_path_segment(original)
                    else:
                        utm_val = visible_text
                    utm_content = f"&utm_content={urllib.parse.quote(utm_val)}"
                    updated_url = original + ("&" if "?" in original else "?") + utm_base[1:] + utm_content

                    final_page.delete_link(link)
                    final_page.insert_link({
                        "from": rect,
                        "uri": updated_url,
                        "kind": 2,
                        "page": final_page.number
                    })
                    preview_page.insert_link({
                        "from": rect,
                        "uri": updated_url,
                        "kind": 2,
                        "page": preview_page.number
                    })

                    red_rects.append((page_num, rect))
                    link_count += 1
                    print(f"üîó Updated: {original} ‚Üí {updated_url}")

        elif job_type == "links_and_utm":
            if not target_format or not base_url:
                raise ValueError("Target format and base URL required.")

            patterns = format_to_regex_list(target_format)
            print("Compiled regex patterns:")
            for p in patterns:
                print(" ‚Üí", p.pattern)

            dict_page = final_page.get_text("dict")

            for block in dict_page["blocks"]:
                for line in block.get("lines", []):
                    for span in line.get("spans", []):
                        raw_text = span.get("text", "")
                        clean_text = unicodedata.normalize("NFKD", raw_text).replace("‚Äì", "-").replace("‚Äî", "-").strip()
                        for pattern in patterns:
                            if pattern.fullmatch(clean_text):
                                rect = fitz.Rect(span["bbox"])
                                full_link = f"{base_url}{clean_text}{utm_base}&utm_content={urllib.parse.quote(clean_text)}"

                                # Insert hyperlinks
                                final_page.insert_link({
                                    "from": rect,
                                    "uri": full_link,
                                    "kind": 2,
                                    "page": final_page.number
                                })
                                preview_page.insert_link({
                                    "from": rect,
                                    "uri": full_link,
                                    "kind": 2,
                                    "page": preview_page.number
                                })

                                # Underline in original text color
                                text_color_int = span.get("color", 0)
                                text_color_rgb = int_to_rgb(text_color_int)
                                underline_y = span["bbox"][3] - 0.5
                                final_page.draw_line(
                                    p1=(span["bbox"][0], underline_y),
                                    p2=(span["bbox"][2], underline_y),
                                    color=text_color_rgb,
                                    width=0.5
                                )

                                red_rects.append((page_num, rect))
                                link_count += 1
                                print(f"üîó Underlined & Linked: {clean_text} ‚Üí {full_link}")
                                break

    return final_pdf, preview_pdf, red_rects, link_count

@app.post("/process")
async def process_clean_pdf(
    user=Depends(verify_firebase_token),
    file: UploadFile = File(...),
    source: str = Form(...),
    medium: str = Form(...),
    campaign: str = Form(...),
    job_type: str = Form(...),
    target_format: Optional[str] = Form(None),
    base_url: Optional[str] = Form(None),
    filename: Optional[str] = Form(None)
):
    try:
        contents = await file.read()
        final_pdf, _, _, link_count = process_pdf_logic(contents, source, medium, campaign, job_type, target_format, base_url)

        output_name = f"{filename.strip()}.pdf" if filename else f"{file.filename.rsplit('.', 1)[0]}_processed.pdf"

        buffer = io.BytesIO()
        final_pdf.save(buffer)
        buffer.seek(0)

        headers = {
            "X-Link-Count": str(link_count),
            "Content-Disposition": f'attachment; filename="{output_name}"'
        }
        
        save_submission(user["uid"], output_name, f"https://yourdomain.com/downloads/{output_name}")print(f"‚úÖ FINAL PDF LINKED: {link_count} as {output_name}")
        return StreamingResponse(buffer, media_type="application/pdf", headers=headers)
    except ValueError as ve:
        return JSONResponse(status_code=400, content={"error": str(ve)})
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})

@app.post("/preview")
async def process_preview_pdf(
    file: UploadFile = File(...),
    source: str = Form(...),
    medium: str = Form(...),
    campaign: str = Form(...),
    job_type: str = Form(...),
    target_format: Optional[str] = Form(None),
    base_url: Optional[str] = Form(None)
):
    try:
        contents = await file.read()
        _, preview_pdf, red_rects, link_count = process_pdf_logic(contents, source, medium, campaign, job_type, target_format, base_url)

        for page_num, rect in red_rects:
            preview_pdf[page_num].draw_rect(rect, color=(1, 0, 0), width=1)

        buffer = io.BytesIO()
        preview_pdf.save(buffer)
        buffer.seek(0)

        headers = {"X-Link-Count": str(link_count)}
        print(f"üëÅÔ∏è PREVIEW GENERATED: {link_count}")
        return StreamingResponse(buffer, media_type="application/pdf", headers=headers)
    except ValueError as ve:
        return JSONResponse(status_code=400, content={"error": str(ve)})
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": str(e)})
